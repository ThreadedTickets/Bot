{"version":3,"file":"index.js","sources":["src/utils/hooks/index.ts"],"sourceRoot":"/","sourcesContent":["import { Client, Guild, Interaction, Message, User } from \"discord.js\";\nimport { Application, ApplicationQuestion } from \"../../types/Application\";\nimport { Locale } from \"../../types/Locale\";\nimport { TicketFormResponse, TicketTrigger } from \"../../types/Ticket\";\nimport { onError } from \"../onError\";\nimport logger from \"../logger\";\n\n// hooks/index.ts\ntype HookHandler = (data: any) => Promise<void> | void;\n\ninterface RegisteredHook {\n  handler: HookHandler;\n  priority: number;\n}\n\nconst hookRegistry: Record<string, RegisteredHook[]> = {};\n\n/**\n * Register a hook for an event, with an optional priority.\n * Higher priority hooks run before lower ones.\n *\n * @param event - the hook event name\n * @param handler - the callback\n * @param priority - hook priority (default 0). Higher priorities are run first\n */\nexport function registerHook(\n  event: string,\n  handler: HookHandler,\n  priority = 0\n) {\n  if (!hookRegistry[event]) hookRegistry[event] = [];\n  hookRegistry[event].push({ handler, priority });\n}\n\ntype HookEventMap = {\n  TestEvent: string;\n  ApplicationStart: {\n    lang: Locale;\n    application: Application;\n    user: User;\n    server: Guild;\n  };\n  ApplicationEnd: {\n    client: Client;\n    application: Application;\n    responses: {\n      applicationId: string;\n      startTime: Date;\n      server: string;\n      questionNumber: number;\n      questions: ApplicationQuestion[];\n\n      responses: { question: string; response: string }[];\n    };\n    owner: string;\n  };\n  ApplicationFinal: {\n    client: Client;\n    application: Application;\n    responses: {\n      applicationId: string;\n      startTime: Date;\n      server: string;\n      questionNumber: number;\n      questions: ApplicationQuestion[];\n\n      responses: { question: string; response: string }[];\n    };\n    owner: string;\n    id: string;\n  };\n  TicketCreate: {\n    client: Client;\n    trigger: TicketTrigger;\n    guild: Guild;\n    responses: TicketFormResponse[];\n    owner: string;\n    messageOrInteraction: Message | Interaction;\n    lang: Locale;\n    user: User;\n  };\n};\n\ntype HookEvent = {\n  [K in keyof HookEventMap]: {\n    event: K;\n    data: HookEventMap[K];\n  };\n}[keyof HookEventMap];\n\n/**\n * Run all hooks for an event, sorted by descending priority.\n */\nexport async function runHooks<K extends keyof HookEventMap>(\n  event: K,\n  data: HookEventMap[K]\n) {\n  const list = hookRegistry[event];\n  if (!list || list.length === 0) return;\n\n  // sort by priority DESC\n  const sorted = list\n    .slice() // copy\n    .sort((a, b) => b.priority - a.priority);\n\n  for (const { handler } of sorted) {\n    try {\n      await handler(data);\n    } catch (err: any) {\n      logger.error(`Error with hook ${event}`, err);\n      onError(err, { event: event, data: data });\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAyBA,oCAOC;AA6DD,4BAoBC;AA7GD,wCAAqC;AACrC,uDAA+B;AAU/B,MAAM,YAAY,GAAqC,EAAE,CAAC;AAE1D;;;;;;;GAOG;AACH,SAAgB,YAAY,CAC1B,KAAa,EACb,OAAoB,EACpB,QAAQ,GAAG,CAAC;IAEZ,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;QAAE,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;IACnD,YAAY,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;AAClD,CAAC;AA0DD;;GAEG;AACI,KAAK,UAAU,QAAQ,CAC5B,KAAQ,EACR,IAAqB;IAErB,MAAM,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;IACjC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO;IAEvC,wBAAwB;IACxB,MAAM,MAAM,GAAG,IAAI;SAChB,KAAK,EAAE,CAAC,OAAO;SACf,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;IAE3C,KAAK,MAAM,EAAE,OAAO,EAAE,IAAI,MAAM,EAAE,CAAC;QACjC,IAAI,CAAC;YACH,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;QACtB,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,gBAAM,CAAC,KAAK,CAAC,mBAAmB,KAAK,EAAE,EAAE,GAAG,CAAC,CAAC;YAC9C,IAAA,iBAAO,EAAC,GAAG,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;QAC7C,CAAC;IACH,CAAC;AACH,CAAC","debug_id":"02d1b092-cfbd-59ad-b891-75851c3bb55c"}