{"version":3,"file":"Scheduler.js","sources":["src/utils/Scheduler.ts"],"sourceRoot":"/","sourcesContent":["import { formatDuration } from \"./formatters/duration\";\nimport logger from \"./logger\";\nimport redis from \"./redis\";\n\ntype TaskFunction = (params?: any) => Promise<void> | void;\n\ninterface StoredTask {\n  runAt: number;\n  functionKey: string;\n  params?: any;\n}\n\ninterface ScheduledTask {\n  runAt: number;\n  timeoutId: NodeJS.Timeout;\n  functionKey: string;\n  params?: any;\n}\n\nexport class TaskScheduler {\n  private redis;\n  private tasks: Map<string, ScheduledTask> = new Map();\n  private taskRegistry: Map<string, TaskFunction> = new Map();\n  private processingBacklog = false;\n\n  constructor() {\n    this.redis = redis;\n  }\n\n  /** Register a named task function */\n  registerTaskFunction(key: string, fn: TaskFunction) {\n    this.taskRegistry.set(key, fn);\n  }\n\n  /** Schedule a task by function key with optional params and delay */\n  async scheduleTask(\n    functionKey: string,\n    params: any,\n    delayMs: number,\n    taskId?: string\n  ): Promise<string> {\n    if (!this.taskRegistry.has(functionKey)) {\n      throw new Error(`No registered task function for key \"${functionKey}\"`);\n    }\n    taskId = taskId || this._generateTaskId();\n    const runAt = Date.now() + delayMs;\n\n    const taskData: StoredTask = { runAt, functionKey, params };\n    await this.redis.hset(\"scheduled_tasks\", taskId, JSON.stringify(taskData));\n\n    const timeoutId = setTimeout(async () => {\n      await this._runTask(taskId, functionKey, params);\n    }, delayMs);\n\n    this.tasks.set(taskId, { runAt, timeoutId, functionKey, params });\n    return taskId;\n  }\n\n  /** Remove a scheduled task */\n  async removeTask(taskId: string): Promise<boolean> {\n    const task = this.tasks.get(taskId);\n    if (task) {\n      clearTimeout(task.timeoutId);\n      this.tasks.delete(taskId);\n      await this.redis.hdel(\"scheduled_tasks\", taskId);\n      return true;\n    }\n    const removed = await this.redis.hdel(\"scheduled_tasks\", taskId);\n    return removed > 0;\n  }\n\n  /**\n   * Check if a task exists and optionally return its details\n   * @param taskId The ID of the task to check\n   * @param returnTask If true, returns the task details when found\n   * @returns boolean or the task details if returnTask is true and task exists\n   */\n  async taskExists(taskId: string, returnTask?: false): Promise<boolean>;\n  async taskExists(\n    taskId: string,\n    returnTask: true\n  ): Promise<{\n    taskId: string;\n    runAt: number;\n    functionKey: string;\n    params?: any;\n  } | null>;\n  async taskExists(\n    taskId: string,\n    returnTask = false\n  ): Promise<\n    | boolean\n    | { taskId: string; runAt: number; functionKey: string; params?: any }\n    | null\n  > {\n    // Check in-memory tasks first\n    const inMemoryTask = this.tasks.get(taskId);\n    if (inMemoryTask) {\n      return returnTask\n        ? {\n            taskId,\n            runAt: inMemoryTask.runAt,\n            functionKey: inMemoryTask.functionKey,\n            params: inMemoryTask.params,\n          }\n        : true;\n    }\n\n    // Check Redis if not found in memory\n    const taskData = await this.redis.hget(\"scheduled_tasks\", taskId);\n    if (taskData) {\n      try {\n        const parsed: StoredTask = JSON.parse(taskData);\n        return returnTask ? { taskId, ...parsed } : true;\n      } catch {\n        return returnTask ? null : false;\n      }\n    }\n\n    return returnTask ? null : false;\n  }\n\n  /** List all tasks */\n  async listTasks(): Promise<\n    Array<{ taskId: string; runAt: number; functionKey: string; params?: any }>\n  > {\n    const all = await this.redis.hgetall(\"scheduled_tasks\");\n    return Object.entries(all).map(([taskId, data]) => {\n      try {\n        const parsed: StoredTask = JSON.parse(data as string);\n        return { taskId, ...parsed };\n      } catch {\n        return { taskId, runAt: 0, functionKey: \"\", params: undefined };\n      }\n    });\n  }\n\n  /** Load tasks from Redis and run expired ones with a queue delay */\n  async loadAndProcessBacklog(queueDelayMs = 500): Promise<void> {\n    if (this.processingBacklog) return;\n    this.processingBacklog = true;\n\n    const start = Date.now();\n    logger.info(\"Starting to process backlog tasks...\");\n\n    const allTasks = await this.listTasks();\n    const now = Date.now();\n\n    for (const task of allTasks) {\n      const fn = this.taskRegistry.get(task.functionKey);\n      if (!fn) {\n        logger.debug(\n          `No registered function for task ${task.taskId} with key ${task.functionKey}. Removing task.`\n        );\n        await this.redis.hdel(\"scheduled_tasks\", task.taskId);\n        continue;\n      }\n\n      const delay = task.runAt - now;\n\n      if (delay <= 0) {\n        // Task expired — run immediately with queue delay\n        await this._runTask(task.taskId, task.functionKey, task.params);\n        await this._delay(queueDelayMs);\n      } else {\n        // Task in the future — reschedule with timeout\n        const timeoutId = setTimeout(async () => {\n          await this._runTask(task.taskId, task.functionKey, task.params);\n        }, delay);\n\n        this.tasks.set(task.taskId, {\n          runAt: task.runAt,\n          timeoutId,\n          functionKey: task.functionKey,\n          params: task.params,\n        });\n      }\n    }\n\n    const elapsed = Date.now() - start;\n    logger.info(\n      `Finished processing backlog tasks in ${formatDuration(elapsed)}`\n    );\n    this.processingBacklog = false;\n  }\n\n  /** Internal: run the task and cleanup */\n  private async _runTask(\n    taskId: string,\n    functionKey: string,\n    params?: any\n  ): Promise<void> {\n    try {\n      const fn = this.taskRegistry.get(functionKey);\n      if (!fn) throw new Error(`Function \"${functionKey}\" not registered`);\n\n      await fn(params);\n    } catch (err: any) {\n      logger.error(`Error running task ${taskId}`, err);\n    }\n    this.tasks.delete(taskId);\n    await this.redis.hdel(\"scheduled_tasks\", taskId);\n  }\n\n  /** Simple delay helper */\n  private _delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /** Generate random ID */\n  private _generateTaskId(): string {\n    return `task_${Math.random().toString(36).slice(2, 10)}`;\n  }\n}\n"],"names":[],"mappings":"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","debug_id":"9e31ff6c-7fee-539e-806f-de2d82c42b1c"}